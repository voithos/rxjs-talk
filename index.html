<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/white.css">
    <link rel="stylesheet" href="lib/css/dracula.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.5.6/Rx.js"></script>
    <script src="js/presentation.js"></script>
    <style>
      .caption {
        bottom: 0px;
        right: 0px;
        position: absolute;
      }
      iframe {
        width: 100%;
      }
    </style>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <!-- ==== Slides start ==== -->

        <section data-markdown>
          <textarea data-template>
            # Observables through space and time

            <small class="caption">by Zaven Muradyan</small>
            <aside class="notes">
              Notes:
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## What are observables?

            ![wormhole](img/wormhole.jpg) <!-- .element: class="fragment" data-fragment-index="1" -->

            <aside class="notes">
              Notes:
              - basically spacetime
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## No, seriously

            | | _Single value_ | _Multi value_ |
            |-------------------|----------|-------------|
            | **Synchronous**   | scalars  | arrays      |
            | **Asynchronous**  | Promises | Observables <!-- .element: class="fragment highlight-red" data-fragment-index="1" --> |

            <aside class="notes">
              Notes:
              - this is one mental model
              - time vs space
              - scalars are just singular, sync values
              - arrays encode a set of multiple values/scalars
              - Promises encode a single asynchronous value
              - Observables encode multiple values over time
              - support concurrency
              - can represent several different kinds of things:
                - events
                - changing state
                - asynchronously-fetched set of data
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Space and time

            ```typescript
            // A simple value, synchronous in nature.
            const scalar = 123;

            // Multiple values, synchronous. Adds a dimension of space.
            const array = ['H', 'e', 'l', 'l', 'o'];

            // Single value, asynchronous. Adds a dimension of time.
            const promise = new Promise(
                    (resolve) => setTimeout(resolve, 1000));
            promise.then(() => { ... });

            // Multiple values, asynchronous.
            // Adds both space and time dimensions.
            const observable = Observable.interval(1000);
            observable.subscribe(() => { ... });
            ```

            <aside class="notes">
              Notes:
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## But also...

            | | _Eager_ | _Lazy_ |
            |-------------------|----------|-------------|
            | **Synchronous**   | scalars  | functions   |
            | **Asynchronous**  | Promises | Observables <!-- .element: class="fragment highlight-red" data-fragment-index="1" --> |

            <aside class="notes">
              Notes:
              - observables are lazy
              - represent executions of some operation at a later point in time
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Why use them?

            Observables are powerful:

            - Can encode change over time, events, finite or infinite
            - Support error-handling
            - Support cancellation
            - Support laziness (key terms: "cold", "hot")
            - Come with a rich set of operators

            <aside class="notes">
              Notes:
              - in some ways higher-level than promises
                - can contain multiple values
                - support cancellation
              - but actually lower-level
                - can implement promises with observables, but not the other way around
                - observable emissions can actually be synchronous
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## What does this have to do with Angular?

            Observables are used extensively in Angular for its APIs and
            patterns. Examples:

            - Route parameters
            - `HttpClient`
            - `AsyncPipe` (more on that later)

            <aside class="notes">
              Notes:
              - Angular has built-in support for rendering the results of async operations
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## RxJS

            RxJS is a library that implements observables, with a goal of
            modeling/following the [proposed spec](https://github.com/tc39/proposal-observable).

            <aside class="notes">
              Notes:
              - comes with a rich set of operators
              - incidentally, there is also discussion about introducing observables via the WHATWG
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Anatomy of an observable

            <pre><code class="typescript" data-trim data-noescape>
            <span class="fragment highlight-current-red" data-fragment-index="4">const subscription =</span>
                <span class="fragment highlight-current-red" data-fragment-index="1">Observable.interval(1000)</span>
                <span class="fragment highlight-current-red" data-fragment-index="2">.pipe(
                    map(x => Math.random() * x)
                    filter(x => x < 1)
                )</span>
                <span class="fragment highlight-current-red" data-fragment-index="3">.subscribe(x => console.log(`Logged ${x}`));</span>
            </code></pre>

            <div style="position: relative">

              <span>Observable</span> <!-- .element: class="fragment current-visible" data-fragment-index="1" -->

              <span>Operators</span> <!-- .element: class="fragment current-visible" data-fragment-index="2" -->

              <span>Observer</span> <!-- .element: class="fragment current-visible" data-fragment-index="3" -->

              <span>Subscription</span> <!-- .element: class="fragment current-visible" data-fragment-index="4" -->

            </div>

            <aside class="notes">
              Notes:
              - 1: the observable itself, represents the stream of values
              - 2: operators, transform the stream
              - 3: observer, receives emissions from the observable
              - 4: subscription, represents the execution of the observable, can be unsubscribed from
                - effectively "calls" the observable
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Anatomy of an observer

            ```typescript
            interface Observer<T> {
              next: (value: T) => void;
              error: (err: any) => void;
              complete: () => void;
            }
            ```

            <aside class="notes">
              Notes:
              - observers are simple - effectively just 3 operations after subscribing
              - next: is called with the next emission
              - error: is called if the observable errors
              - complete: is called if the observable completes successfully
              - in general an errored/completed observable execution can no longer emit
              - `.subscribe()` method can take next/error/complete fns, or an observer obj
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Marble diagrams

            ![marble1](img/marble1.png)
            `map(x => x.toFixed(1))`
            ![marble2](img/marble2.png)

            <aside class="notes">
              Notes:
              - subscription happens at the beginning
              - emissions
              - | is completion
              - X is error
              - none of the operations are dependent on one another, and all are optional
                - don't have to emit before completing
                - might never complete
                - etc
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            # Operators

            There are a lot
            <aside class="notes">
              Notes:
              - will attempt to build-up from simple to complex
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Creation operators

            <aside class="notes">
              Notes:
              - used to create observables from non-observable values
              - e.g. primitives, promises, or even events
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `of`, `interval`, `from`

            ```typescript
            // Outputs: 1, 2, 3, 4
            Observable.of(1, 2, 3, 4)
                .subscribe(x => console.log(x));

            // Outputs: 0, 1, 2, 3, ...
            Observable.interval(500)
                .subscribe(x => console.log(x));

            // Converts the Promise to an observable.
            Observable.from(fetch('spacetime.jpg'))
                .subscribe(blob => ...);
            ```
            <aside class="notes">
              Notes:
              - `of` just outputs what is passed to it
              - synchronous upon subscription
              - `interval` outputs the index
              - `from` can be used for promises, arrays, etc
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `empty`, `throw`, `never`

            - `empty` - never emits, completes immediately
            - `throw` - never emits, errors immediately
            - `never` - never emits, never completes, never errors
            <aside class="notes">
              Notes:
              - not immediately useful, but handy when composing observables (next)
              - effects take place upon execution
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Utility operators

            <aside class="notes">
              Notes:
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `tap`

            ```typescript
            const mouseClicks = ...;
            mouseClicks.pipe(
                // `tap` can be used to perform a side effect
                // without altering the underlying observable.
                tap(v => logToServer(v)),
            )
            .subscribe(v => { ... });
            ```
            <aside class="notes">
              Notes:
              - makes side-effects more clear than they would otherwise
              - might be useful for temporary debugging
              - try to avoid
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `delay`, `timeout`

            ```typescript
            Observable.of(1).pipe(
                // Delays the emissions by 1.5s.
                delay(1500),

                // Errors if nothing is emitted after 1s.
                timeout(1000),
            )
            .subscribe({
              // Outputs: TimeoutError
              error: err => { console.log(err); }
            });
            ```
            <aside class="notes">
              Notes:
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `delay`, `timeout`

            ![delaytimeout1](img/delaytimeout1.gif)

            `delay(1500)`

            ![delaytimeout2](img/delaytimeout2.gif)

            `timeout(1000)`

            ![delaytimeout3](img/delaytimeout3.gif)
            <aside class="notes">
              Notes:
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Transformation operators

            <aside class="notes">
              Notes:
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `map`

            ```typescript
            Observable.interval(750).pipe(
                // Transforms each value to another.
                map(i => i * 10),
            )
            .subscribe(v => { ... });
            ```
            <aside class="notes">
              Notes:
              - also useful for picking properties off objects
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `map`

            ![map1](img/map1.gif)

            `map(i => i * 10)`

            ![map2](img/map2.gif)
            <aside class="notes">
              Notes:
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `scan`

            ```typescript
            // Changes in temperature over time.
            const deltas = ...;
            const currentTemp = 40;
            deltas.pipe(
                // Reduces over time.
                scan((acc, delta) => acc + delta, currentTemp),
            )
            .subscribe(temp => { ... });
            ```
            <aside class="notes">
              Notes:
              - reduce-over-time, or "online" reduce
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `scan`

            ![scan1](img/scan1.gif)

            `scan((acc, delta) => acc + delta)`

            ![scan2](img/scan2.gif)
            <aside class="notes">
              Notes:
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Filtering operators

            <aside class="notes">
              Notes:
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `filter`

            ```typescript
            Observable.interval(500).pipe(
                map(i => Math.random().toFixed(1)),
                // Filters out emissions less than 0.8.
                filter(v => v >= 0.8),
            )
            .subscribe(v => { ... });
            ```
            <aside class="notes">
              Notes:
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `filter`

            ![filter1](img/filter1.gif)

            `filter(v => v >= 0.8)`

            ![filter2](img/filter2.gif)
            <aside class="notes">
              Notes:
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `take`, `takeUntil`, `first`

            ```typescript
            // Takes first 5 emissions, then unsubscribes.
            const five = Observable.interval(1000).pipe(take(5));

            five.pipe(
                // Completes after the given observable emits once.
                takeUntil(Observable.timer(3500)),
            )
            .subscribe(v => { ... });

            // `first()` is a convenient shorthand for `take(1)`.
            ```
            <aside class="notes">
              Notes:
              - important! these complete automatically and thus auto-unsubscribe
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `takeUntil`

            ![takeuntil1](img/takeuntil1.gif)
            ![takeuntil2](img/takeuntil2.gif)

            `takeUntil()`

            ![takeuntil3](img/takeuntil3.gif)
            <aside class="notes">
              Notes:
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Combination operators

            <aside class="notes">
              Notes:
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `merge`

            ```typescript
            // Contains a stream of characters.
            const chars = ...;
            Observable.interval(1000).pipe(
                // `merge` emits for every value from either observable.
                merge(chars),
            )
            .subscribe(v => { ... });
            ```
            <aside class="notes">
              Notes:
              - emits immediately for each source emission
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `merge`

            ![merge1](img/merge1.gif)
            ![merge2](img/merge2.gif)

            `merge()`

            ![merge3](img/merge3.gif)
            <aside class="notes">
              Notes:
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `concat`

            ```typescript
            Observable.interval(500).pipe(
                take(4),
                // Emits from the first observable until it completes,
                // then emits from the concatenated one.
                concat(
                    Observable.interval(1000).pipe(take(2))
                ),
            )
            .subscribe(v => { ... });
            ```
            <aside class="notes">
              Notes:
              - `concat` will keep emitting from a single observable until it completes
              - this happens before the 2nd observable is subscribed to!
              - if it never completes, the 2nd observable will never be subscribed to
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `concat`

            ![concat1](img/concat1.gif)
            ![concat2](img/concat2.gif)

            `concat()`

            ![concat3](img/concat3.gif)
            <aside class="notes">
              Notes:
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `forkJoin`

            ```typescript
            // Waits for all observables to complete, then returns
            // an array of their final values.
            forkJoin(
                this.http.get('/api'),
                webWorkerJob,
            )
            .subscribe(v => { ... });
            ```
            <aside class="notes">
              Notes:
              - with `merge` and `concat`, we saw the pipeable forms
                - but they also have "static" forms, that take multiple observables
              - `forkJoin` just has the static form
              - conceptually similar to Promise.all
              - emits an array of the final values emitted from all observables
              - all observables need to complete!
              - not as widely composable because of this
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `forkJoin`

            ![forkJoin1](img/forkjoin1.gif)
            ![forkJoin2](img/forkjoin2.gif)

            `forkJoin()`

            ![forkJoin3](img/forkjoin3.gif)
            <aside class="notes">
              Notes:
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `startWith`

            ```typescript
            // API call might be somewhat slow...
            this.http.get('/api/processed_tons').pipe(
                // So we can start the observable with an initial value.
                startWith(0),
            )
            .subscribe(v => { ... });
            ```
            <aside class="notes">
              Notes:
              - can be used to provide an initial value to `scan()`
              - generally useful for composing with any other operators that wait on an initial emit
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `startWith`

            ![startwith1](img/startwith1.gif)

            `startWith(0)`

            ![startwith2](img/startwith2.gif)
            <aside class="notes">
              Notes:
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `combineLatest`

            ```typescript
            // Observables of keyboard presses and
            // number pad presses.
            const keyPresses = ...;
            const numpadPresses = ...;

            // Emits an array of the latest values from each
            // observable when any observable emits. Only starts
            // after each observable emits at least once.
            combineLatest(
                keyPresses,
                numpadPresses,
            )
            .subscribe(v => { ... });
            ```
            <aside class="notes">
              Notes:
              - `combineLatest` only emits after each individual observable has
                emitted at least once
              - similar to a continuous `forkJoin`
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `combineLatest`

            ![combinelatest1](img/combinelatest1.gif)
            ![combinelatest2](img/combinelatest2.gif)

            `combineLatest()`

            ![combinelatest3](img/combinelatest3.gif)
            <aside class="notes">
              Notes:
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `withLatestFrom`

            ```typescript
            // Observables of keyboard presses and
            // number pad presses.
            const keyPresses = ...;
            const numpadPresses = ...;

            keyPresses.pipe(
                // Includes the latest value from `numpadPresses`.
                // Will only emit if `numpadPresses` has emitted
                // at least once.
                withLatestFrom(numpadPresses),
            )
            .subscribe(v => { ... });
            ```
            <aside class="notes">
              Notes:
              - very similar example code as `combineLatest`
              - also includes the latest value from another observable
                - but does not emit when that other observable emits
              - if second observable hasn't emitted yet, `withLatestFrom` won't emit!
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `withLatestFrom`

            ![withlatestfrom1](img/combinelatest1.gif)
            ![withlatestfrom2](img/combinelatest2.gif)

            `withLatestFrom()`

            ![withlatestfrom3](img/withlatestfrom3.gif)
            <aside class="notes">
              Notes:
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Higher-order operators

            <aside class="notes">
              Notes:
              - observables are streams of values
              - naturally, the values can be other observables
              - observables of observables are "higher order observables"
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Mapping to observables

            ```typescript
            // Async stream of data IDs.
            const ids = ...;
            const data: Observable<Observable<Data>> = ids.pipe(
                map(id => this.http.get<Data>(`/api/${id}`)),
            );
            // What we really want is a flat `Observable<Data>`.
            ```
            <aside class="notes">
              Notes:
              - in a real application, would try to minimize HTTP requests
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Mapping to observables

            ![higherorder](img/higherorder.gif)
            <aside class="notes">
              Notes:
              - hard to work with
              - definitely don't want to just .subscribe() inside the map()!
                - anti pattern; that would basically be callback hell
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Flattening higher-order observables

            - `mergeAll()` - merges all inner observables
            - `concatAll()` - concats all inner observables
            - `switchAll()` - on each emit, unsubscribes from previous observable and switches to the new one

            <aside class="notes">
              Notes:
              - we want to flatten the observables somehow
              - good news, we can use some of the same operators we already saw
              - `switchAll()` is new; will talk about it in a bit
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Flattening higher-order observables

            ```typescript
            // Observable of buttons whose click events
            // we're interested in.
            const buttons = ...;
            const clicks = buttons.pipe(
                map(btn => Observable.fromEvent(btn, 'click')),
            );

            // These all do related, but different, things.
            const mergedClicks = clicks.pipe(mergeAll());
            const concatenatedClicks = clicks.pipe(concatAll());
            const switchedClicks = clicks.pipe(switchAll());
            ```
            <aside class="notes">
              Notes:
              - will use an example similar to the last one
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `mergeAll()`

            ![mergeall1](img/higherorder2.gif)

            `mergeAll()`

            ![mergeall2](img/mergeall2.gif)
            <aside class="notes">
              Notes:
              - subscribes to each inner observable and merges results
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `concatAll()`

            ![concatall1](img/higherorder2.gif)

            `concatAll()`

            ![concatall2](img/concatall2.gif)
            <aside class="notes">
              Notes:
              - subscribes to each inner observable one the previous one completes
              - in this case, the 2nd one never completes, so we see no emits from the 3rd
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `switchAll()`

            ![switchall1](img/higherorder2.gif)

            `switchAll()`

            ![switchall2](img/switchall2.gif)
            <aside class="notes">
              Notes:
              - switch unsubscribes from previous inner observables whenever a new one is available
              - it also doesn't get hung if an observable does not complete
              - picks the most recent emission, in a sense
              - often the best "default" flattening method
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `mergeMap`, `concatMap`, `switchMap`

            ```typescript
            const inputEvents = Observable.fromEvent(textbox, 'input');
            // This:
            inputEvents.pipe(
                map(e => this.html.get(`/api/input/${e.data}`)),
                switchAll(),
            );
            // ...is equivalent to this:
            inputEvents.pipe(
                switchMap(e => this.html.get(`/api/input/${e.data}`)),
            );
            ```
            <aside class="notes">
              Notes:
              - `map` + flattening is a common idiom, so specific operators exist
              - allows data to stay as first-order observables
              - `switchMap` is usually a better default choice because it has cancellation built-in
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Multicasting operators

            <aside class="notes">
              Notes:
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Sharing execution

            All observables so far have had no multicasting

            Every subscription creates a separate execution

            In many cases, we want to share a single execution
            <aside class="notes">
              Notes:
              - if an observable is piped through mappings, filters, etc, each execution would repeat that work
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `Subject`

            Both an Observer and an Observable

            ```typescript
            const subject = new Subject<number>();
            Observable.interval(1000).pipe(
                take(3),
                tap(v => console.log(`Emit: ${v}`)),
            )
            // This subscription creates one new execution of
            // the observable.
            .subscribe(subject);

            // Even though there are multiple subscriptions on
            // the subject, each 'Emit:' will only print once.
            const sub1 = subject.subscribe(v => { ... });
            const sub2 = subject.subscribe(v => { ... });
            ```
            <aside class="notes">
              Notes:
              - can act as a multicast point
              - allows for more imperative manipulation of observables, but try to avoid this
                - usually a better way to do this with operators
              - trivia: `EventEmitter` is actually a subject
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `share`

            Creates a subject internally, and keeps track of the count of
            subscribers.

            ## But actually, NOPE <!-- .element: class="fragment" style="color: #ff2c2d;" data-fragment-index="1" -->
            <aside class="notes">
              Notes:
              - best to avoid managing a subject manually
              - `share()` creates a subject internally and keeps track of downstream subscribers
              - 0 -> 1 results in the inner observable getting subscribed ("connected")
              - 1 -> 0 results in the inner observable getting unsubscribed
              - but danger, going from 0 -> 1 again will result in a re-execution!
                - often difficult to debug
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `shareReplay`

            Similar to `share`, but replays emissions and never re-subscribes
            to the source observable.

            ```typescript
            const intensiveObservable = ...;

            // Argument indicates how many emissions to replay
            // for new observers. When subscribers drops to 0,
            // source observable is unsubscribed from and never
            // re-subscribed.
            const sharedObservable = intensiveObservable.pipe(
                shareReplay(1),
            );
            ```
            <aside class="notes">
              Notes:
              - uses a `ReplaySubject` under the hood instead of `Subject`
              - new subscribers see the replay
              - once subscribers drop to 0, source is unsubscribed from
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## And more!

            Good resource: https://www.learnrxjs.io/

            Keep an eye on the [rxjs-docs repo](https://github.com/ReactiveX/rxjs-docs)
            <aside class="notes">
              Notes:
              - as is the case with almost all rxjs docs, learnrxjs needs some updates :(
              - caveats: some pages use pipeables, while others don't; not everything is there
              - rxjs-docs is supposed to be the future of docs
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            # Patterns

            <aside class="notes">
              Notes:
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Passing values to the template

            ```typescript
            @Component({
              template: `<div>{{curvature}}<div>`,
            })
            export class UniverseComponent implements OnInit {
              curvature: number;
              constructor(private service: SpaceTimeService) {}
              ngOnInit() {
                this.service.calcCurvature().subscribe(v => {
                  this.curvature = v;
                });
              }
            }
            ```

            ## But actually, NOPE <!-- .element: class="fragment" style="color: #ff2c2d;" data-fragment-index="1" -->
            <aside class="notes">
              Notes:
              - performing an async calculation and setting the value to the cmp
              - NOPE: this should generally be avoided, since now the cmp has to manage a subscription
              - explicit `.subsribe()` calls should be avoided (code smell)
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Using AsyncPipe

            ```typescript
            @Component({
              template: `<div>{{curvature | async}}<div>`,
            })
            export class UniverseComponent implements OnInit {
              curvature: Observable<number>;
              constructor(private service: SpaceTimeService) {}
              ngOnInit() {
                this.curvature = this.service.calcCurvature();
              }
            }
            ```
            <aside class="notes">
              Notes:
              - async subscribes to an observable and returns the latest value it emits
              - automatically unsubscribes via Angular's component lifecycle
              - still an observable, so can be easily manipulated
              - caveats:
                - returns `null` until the observable actually emits, so blindly accessing properties on the result is dangerous
                - if it makes sense, that could be worked around via `startWith()`
                - each use of `async` creates a separate subscription! multiple executions if not multicasted
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Multiple AsyncPipes

            ```typescript
            @Component({
              template: `
                <div>
                  Universe curvature is {{curvature | async}}!
                  {{curvature | async}}!!!1
                <div>`,
            })
            export class UniverseComponent implements OnInit {
              ...
              ngOnInit() {
                this.curvature = this.service.calcCurvature().pipe(
                    // Ensures that source observable is only
                    // executed once.
                    shareReplay(1),
                );
              }
            }
            ```
            <aside class="notes">
              Notes:
              - async subscribes to an observable and returns the latest value it emits
              - automatically unsubscribes via Angular's component lifecycle
              - still an observable, so can be easily manipulated
              - caveats:
                - returns `null` until the observable actually emits, so blindly accessing properties on the result is dangerous
                - each use of `async` creates a separate subscription! multiple executions if not multicasted
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Managing subscriptions

            If an explicit `.subscribe()` is needed

            ```typescript
            @Component({ ... })
            export class UniverseComponent implements OnDestroy {
              private onDestroy = new Subject<void>();
              ngOnDestroy() {
                // Attach to the component's lifecycle.
                this.onDestroy.next();
              }
              createGalaxy(): void {
                this.http.post('/api/galaxy', this.data).pipe(
                    switchMap(...),
                    filter(...),
                    // Ensure that this subscription is cleaned
                    // up on component destruction.
                    takeUntil(this.onDestroy),
                )
                .subscribe();
              }
            }
            ```
            <aside class="notes">
              Notes:
              - if `async` isn't appropriate, or an explicit .subscribe() is needed for some other reason...
              - can use an `onDestroy` Subject with `takeUntil` to ensure that subscriptions are cleaned up
              - orphaned subscriptions can cause memory leaks
              - also good to choose the minimize observable lifetime in other ways
                - `first()`, `take(n)`, etc
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Managing state-over-time

            ```typescript
            @Component({ ... })
            export class UniverseComponent {
              // How can we manage this state over time, when it can
              // potentially be loaded and mutated asynchronously?
              galaxies: Galaxy[];
            }
            ```
            <aside class="notes">
              Notes:
              - caveat: this pattern hasn't been vetted "in the wild"
              - wouldn't want to use explicit .subscribe()s
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Managing state-over-time

            ```typescript
            @Component({ ... })
            export class UniverseComponent implements OnInit {
              // Use in the template with `async`.
              galaxies: Observable<Galaxy[]>;
              deletedGalaxies = new Subject<Galaxy[]>();
              ngOnInit() {
                // `applyStateTransforms` applies the given transforms
                // to the observable of starting data, over time.
                this.galaxies = applyStateTransforms(
                    this.route.data.galaxies,
                    // `stateTransforms` generates the transforms based
                    // on an observable of events and a reducer.
                    stateTransforms(this.deletedGalaxies, deleteReducer),
                );
              }
              deleteGalaxies(galaxies: Galaxy[]) {
                this.universeService.deleteGalaxies(galaxies)
                    .subscribe(this.deletedGalaxies);
              }
            }
            ```
            <aside class="notes">
              Notes:
              - `galaxies` can be used in the template directly, with async
              - the transforms are applied over time to the initial state
              - when calling `deleteGalaxies` on the service, could also do a `takeUntil(this.onDestroy)`
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## State transform reducer

            ```typescript
            function deleteReducer(
                galaxies: Galaxy[], deletedGalaxies: Galaxy[]) {
              const deletedIds = new Set(deletedGalaxies.map(g => g.id));
              return galaxies.filter(g => !deletedIds.has(g.id));
            }
            ```
            <aside class="notes">
              Notes:
              - reducer operates on simple arrays, is quite simple
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `stateTransforms`

            ```typescript
            function stateTransforms<S, A>(
                actions: Observable<A>,
                reducer: (state: S, action: A) => S
                ): Observable<(state: S) => S> {
              return actions.pipe(
                  map((action: A) => (state: S) =>
                      reducer(state, action)),
              );
            }
            ```
            <aside class="notes">
              Notes:
              - generates an observable of "state transformation functions" - S => S
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## `applyStateTransforms`

            ```typescript
            function applyStateTransforms<S>(
                state: Observable<S>,
                ...transforms: Array<Observable<(state: S) => S>>
                ): Observable<S> {
              const mergedTransforms = merge(...transforms);
              return state.pipe(
                switchMap(startState => transforms.pipe(
                  scan((state, trans) => trans(state), startState),
                  startWith(startState),
                )),
              );
            }
            ```
            <aside class="notes">
              Notes:
              - merges all the transforms (so there can be many)
              - switchMap's the state observable, meaning it will take precedence
            </aside>
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            # Thanks!

            <sup>Visualizations made with https://rxviz.com/</sup>

            <aside class="notes">
              Notes:
            </aside>
          </textarea>
        </section>

        <!-- ==== Slides end ==== -->
      </div>
    </div>
    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script>
      Reveal.initialize({
        history: true,
        dependencies: [
          // Interpret Markdown in <section> elements
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },

          // Syntax highlight for <code> elements
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

          // Speaker notes
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });
    </script>
  </body>
</html>
